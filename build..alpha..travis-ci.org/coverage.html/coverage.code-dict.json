{"/home/travis/build/npmtest/node-npmtest-next-update/test.js":"/* istanbul instrument in package npmtest_next_update */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-next-update/lib.npmtest_next_update.js":"/* istanbul instrument in package npmtest_next_update */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_next_update = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_next_update = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-next-update/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-next-update && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_next_update */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_next_update\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_next_update.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_next_update.rollup.js'] =\n            local.assetsDict['/assets.npmtest_next_update.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_next_update.__dirname + '/lib.npmtest_next_update.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/index.js":"var q = require('q');\nq.longStackSupport =  true;\n\nif (!module.parent) {\n  throw new Error('Please run bin/next-update.js for stand alone CLI tool');\n}\n\nmodule.exports = require('./src/next-update-as-module');\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/next-update-as-module.js":"var nextUpdate = require('./next-update');\n\nmodule.exports = function nextUpdateTopLevel(options) {\n  options = options || {};\n  var opts = {\n    names: options.module,\n    testCommand: options.test,\n    latest: Boolean(options.latest),\n    keep: Boolean(options.keep),\n    color: Boolean(options.color || options.colors),\n    allow: options.allow || options.allowed,\n    type: options.type,\n    changedLog: options['changed-log']\n  };\n\n  var checkUpdates = nextUpdate.checkAllUpdates.bind(null, opts);\n\n  return nextUpdate.checkCurrentInstall(opts)\n    .then(checkUpdates);\n};\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/next-update.js":"var la = require('lazy-ass');\r\nvar check = require('check-more-types');\r\nvar verify = check.verify;\r\nrequire('console.json');\r\n\r\nvar log = require('debug')('next-update');\r\nvar Q = require('q');\r\nQ.longStackSupport = true;\r\nvar depsOk = require('deps-ok');\r\nvar _ = require('lodash');\r\n\r\nvar nameVersionParser = require('./moduleName');\r\nvar registry = require('./registry');\r\nvar nextVersions = registry.nextVersions;\r\nvar testVersions = require('./test-module-version').testModulesVersions;\r\nvar runTest = require('./test-module-version').testPromise;\r\nvar getDependenciesToCheck = require('./dependencies');\r\nvar reportAvailable = require('./report-available');\r\nvar npmUtils = require('npm-utils');\r\n\r\nvar boundConsoleLog = console.log.bind(console);\r\n\r\n// returns a promise\r\nfunction available(moduleName, options) {\r\n    options = options || {};\r\n    var toCheck = getDependenciesToCheck(options, moduleName);\r\n    la(check.array(toCheck), 'expected object of deps to check, was', toCheck);\r\n    var toCheckHash = _.zipObject(\r\n        _.pluck(toCheck, 'name'),\r\n        _.pluck(toCheck, 'version')\r\n    );\r\n\r\n    log('need to check these dependencies');\r\n    log(toCheckHash);\r\n\r\n    var nextVersionsPromise = nextVersions(options, toCheck);\r\n    return nextVersionsPromise.then(function (info) {\r\n        return reportAvailable(info, toCheckHash, options);\r\n    }, function (error) {\r\n        console.error('Could not fetch available modules\\n', error);\r\n    });\r\n}\r\n\r\nfunction checkDependenciesInstalled() {\r\n    var defer = Q.defer();\r\n    process.nextTick(function () {\r\n        if (depsOk(process.cwd())) {\r\n            defer.resolve();\r\n        } else {\r\n            var msg = 'Current installation is incomplete. Please run `npm install` or `bower install` first';\r\n            defer.reject(new Error(msg));\r\n        }\r\n    });\r\n    return defer.promise;\r\n}\r\n\r\nfunction cleanDependencies() {\r\n    var update = _.partial(npmUtils.test, 'npm update');\r\n    var prune = _.partial(npmUtils.test, 'npm prune');\r\n    return update().then(prune);\r\n}\r\n\r\nfunction checkCurrentInstall(options) {\r\n    options = options || {};\r\n    var log = options.tldr ? _.noop : boundConsoleLog;\r\n    log('checking if the current state works');\r\n\r\n    return cleanDependencies()\r\n        .then(checkDependenciesInstalled)\r\n        .then(function () {\r\n            return runTest(options, options.testCommand)();\r\n        })\r\n        .then(function () {\r\n            console.log('> tests are passing at the start');\r\n        });\r\n}\r\n\r\nvar isOnline = Q.denodeify(require('is-online'));\r\n\r\nfunction isSingleItem(names) {\r\n    return names &&\r\n        check.array(names) &&\r\n        names.length === 1;\r\n}\r\n\r\nfunction makeSureValidModule(moduleNames, checkingModules) {\r\n    la(check.maybe.array(moduleNames), 'expected list of modules', moduleNames);\r\n    la(check.array(checkingModules), 'expected list of modules to check', checkingModules);\r\n    if (isSingleItem(moduleNames) && check.empty(checkingModules)) {\r\n        console.error('Could not find module \"%s\" in the list of dependencies', moduleNames[0]);\r\n        console.error('Please check the name');\r\n        process.exit(-1);\r\n    }\r\n}\r\n\r\n// returns promise\r\nfunction checkAllUpdates(options) {\r\n    options = options || {};\r\n    var moduleName = options.names;\r\n    var checkLatestOnly = !!options.latest;\r\n    var checkCommand = options.testCommand;\r\n    if (checkCommand) {\r\n        verify.unemptyString(checkCommand, 'invalid test command ' + checkCommand);\r\n    }\r\n    var all = options.all;\r\n    if (all) {\r\n        checkLatestOnly = true;\r\n        console.log('will check only latest versions because testing all');\r\n    }\r\n\r\n    if (check.string(moduleName)) {\r\n        moduleName = [moduleName];\r\n    }\r\n    checkLatestOnly = !!checkLatestOnly;\r\n    if (checkCommand) {\r\n        check.verify.string(checkCommand, 'expected string test command');\r\n    }\r\n    var toCheck = getDependenciesToCheck(options, moduleName);\r\n    check.verify.array(toCheck, 'dependencies to check should be an array');\r\n\r\n    makeSureValidModule(moduleName, toCheck);\r\n\r\n    var testVersionsBound = testVersions.bind(null, {\r\n        modules: toCheck,\r\n        command: checkCommand,\r\n        all: all,\r\n        color: options.color,\r\n        keep: options.keep,\r\n        allowed: options.allow || options.allowed,\r\n        tldr: options.tldr,\r\n        type: options.type\r\n    });\r\n\r\n    return isOnline()\r\n        .then(function (online) {\r\n            if (!online) {\r\n                throw new Error('Need to be online to check new modules');\r\n            }\r\n        }).then(function () {\r\n            if (isSingleSpecificVersion(moduleName)) {\r\n                var nv = nameVersionParser(moduleName[0]);\r\n                console.log('checking only specific:', nv.name, nv.version);\r\n                var list = [{\r\n                    name: nv.name,\r\n                    versions: [nv.version]\r\n                }];\r\n                return testVersionsBound(list);\r\n            } else {\r\n                var nextVersionsPromise = nextVersions(options, toCheck, checkLatestOnly);\r\n                return nextVersionsPromise.then(testVersionsBound);\r\n            }\r\n        });\r\n\r\n}\r\n\r\nfunction isSingleSpecificVersion(moduleNames) {\r\n    if (!moduleNames) {\r\n        return false;\r\n    }\r\n    var name = moduleNames;\r\n    if (Array.isArray(moduleNames)) {\r\n        if (moduleNames.length !== 1) {\r\n            return false;\r\n        }\r\n        name = moduleNames[0];\r\n    }\r\n    check.verify.string(name, 'expected module name string, not ' +\r\n        JSON.stringify(name));\r\n    var parsed = nameVersionParser(name);\r\n    if (check.object(parsed)) {\r\n        return false;\r\n    }\r\n    return check.string(parsed.version);\r\n}\r\n\r\nmodule.exports = {\r\n    checkCurrentInstall: checkCurrentInstall,\r\n    checkAllUpdates: checkAllUpdates,\r\n    available: available\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/moduleName.js":"'use strict';\n\nvar check = require('check-more-types');\n\nfunction isScopedName(str) {\n    return str[0] === '@' && str.indexOf('/') !== -1;\n}\n\nfunction parseScopedName(str) {\n    var parsed = moduleName(str.substr(1));\n    parsed.name = '@' + parsed.name;\n    return parsed;\n}\n\nfunction moduleName(str) {\n    check.verify.string(str, 'expected string module name');\n\n    if (isScopedName(str)) {\n      return parseScopedName(str);\n    }\n\n    var parts = str.split('@');\n    return {\n        name: parts[0],\n        version: parts[1]\n    };\n}\n\nmodule.exports = moduleName;\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/registry.js":"'use strict';\n\nvar la = require('lazy-ass');\nvar check = require('check-more-types');\nvar log = require('debug')('next-update');\n\nvar request = require('request');\nvar verify = check.verify;\nvar semver = require('semver');\nvar q = require('q');\nvar localVersion = require('./local-module-version');\nvar isUrl = require('npm-utils').isUrl;\nvar _ = require('lodash');\n\nvar _registryUrl = require('npm-utils').registryUrl;\nla(check.fn(_registryUrl), 'expected registry url function');\nvar registryUrl = _.once(_registryUrl);\n\nfunction cleanVersion(version, name) {\n    var originalVersion = version;\n    verify.unemptyString(version, 'missing version string' + version);\n    verify.unemptyString(name, 'missing name string' + name);\n\n    if (isUrl(version)) {\n        // version = version.substr(version.indexOf('#') + 1);\n\n        // hmm, because we don't have a way to fetch git tags yet\n        // just skip these dependencies\n        console.log('Cannot handle git repos, skipping', name, 'at', version);\n        return;\n    }\n    if (version === 'original' ||\n        version === 'modified' ||\n        version === 'created') {\n        return;\n    }\n\n    version = version.replace('~', '').replace('^', '');\n    var twoDigitVersion = /^\\d+\\.\\d+$/;\n    if (twoDigitVersion.test(version)) {\n        version += '.0';\n    }\n    if (version === 'latest' || version === '*') {\n        console.log('Module', name, 'uses version', version);\n        console.log('It is recommented to list a specific version number');\n        version = localVersion(name);\n        if (!version) {\n            version = '0.0.1';\n        }\n        console.log('module', name, 'local version', version);\n    }\n    try {\n        version = semver.clean(version);\n    } catch (err) {\n        console.error('exception when cleaning version', version);\n        return;\n    }\n    if (!version) {\n        log('could not clean version ' + originalVersion + ' for ' + name);\n        return;\n    }\n    console.assert(version, 'missing clean version ' + originalVersion + ' for ' + name);\n    return version;\n}\n\nfunction cleanVersionPair(nameVersion) {\n    check.verify.array(nameVersion, 'expected an array');\n    console.assert(nameVersion.length === 2,\n        'expected 2 items, name and version ' + nameVersion);\n    var name = nameVersion[0];\n    check.verify.string(name, 'could not get module name from ' + nameVersion);\n\n    var version = nameVersion[1];\n    check.verify.string(version, 'could not get module version from ' + nameVersion);\n    version = cleanVersion(version, name);\n    if (!version) {\n        return;\n    }\n\n    nameVersion[1] = version;\n    return nameVersion;\n}\n\nfunction cleanVersionObject(info) {\n    check.verify.object(info, 'expected info');\n    var name = info.name;\n    check.verify.string(name, 'could not get module name from ' + info);\n\n    var version = info.version;\n    check.verify.string(version, 'could not get module version from ' + info);\n    version = cleanVersion(version, name);\n\n    if (!version) {\n        return;\n    }\n\n    info.version = version;\n    return info;\n}\n\nfunction cleanVersions(nameVersionPairs) {\n    check.verify.array(nameVersionPairs, 'expected array');\n    var cleaned = nameVersionPairs\n        .map(cleanVersionObject)\n        .filter(check.object);\n    return cleaned;\n}\n\nfunction formNpmErrorMessage(name, info) {\n    var reason = info.reason || info.error || JSON.stringify(info);\n    var str = 'ERROR in npm info for ' + name + ' reason ' + reason;\n    return str;\n}\n\nfunction cleanVersionFor(name, version) {\n    return cleanVersion(version, name);\n}\n\nfunction extractVersions(info) {\n    if (info.time) {\n        return Object.keys(info.time);\n    }\n    if (info.versions) {\n        return Object.keys(info.versions);\n    }\n}\n\nfunction is404(response) {\n    return response && response.statusCode === 404;\n}\n\nfunction isNotFound(str) {\n    var moduleNotFound = (/not found/).test(str);\n    var cannotConnect = (/ENOTFOUND/).test(str);\n    var errorInNpm = (/ERROR in npm/).test(str);\n    var couldNotFetch = (/could not fetch/i).test(str);\n    return moduleNotFound || cannotConnect || errorInNpm || couldNotFetch;\n}\n\n// fetching versions inspired by\n// https://github.com/jprichardson/npm-latest\n// returns a promise\nfunction fetchVersions(nameVersion) {\n    // console.log(nameVersion);\n    // TODO use check.schema\n    check.verify.object(nameVersion, 'expected name, version object');\n    var name = nameVersion.name;\n    var version = nameVersion.version;\n    check.verify.string(name, 'missing name string');\n    check.verify.string(version, 'missing version string');\n\n    var cleanVersionForName = _.partial(cleanVersionFor, name);\n    function isLaterVersion(ver) {\n        var later = semver.gt(ver, version);\n        return later;\n    }\n\n    // console.log('fetching versions for', name, 'current version', version);\n    var MAX_WAIT_TIMEOUT = 25000;\n    var deferred = q.defer();\n\n    function rejectOnTimeout() {\n        var msg = 'timed out waiting for NPM for package ' + name +\n            ' after ' + MAX_WAIT_TIMEOUT + 'ms';\n        console.error(msg);\n        deferred.reject(msg);\n    }\n\n    function escapeName(str) {\n        return str.replace('/', '%2F');\n    }\n\n    registryUrl().then(function (npmUrl) {\n        log('NPM registry url', npmUrl);\n        la(check.webUrl(npmUrl), 'need npm registry url, got', npmUrl);\n\n        npmUrl = npmUrl.replace(/^https:/, 'http:').trim();\n        var url = npmUrl + escapeName(name);\n\n        // TODO how to detect if the registry is not responding?\n\n        log('getting url', url);\n        request.get(url, onNPMversions);\n        var timer = setTimeout(rejectOnTimeout, MAX_WAIT_TIMEOUT);\n\n        function onNPMversions(err, response, body) {\n            log('got response for', url);\n            clearTimeout(timer);\n\n            if (err) {\n                console.error('ERROR when fetching info for package', name);\n                deferred.reject(err.message);\n                return;\n            }\n\n            if (is404(response)) {\n                log('404 response for', url);\n                deferred.resolve({\n                    name: name,\n                    versions: []\n                });\n                return;\n            }\n\n            try {\n                log('parsing response body');\n                var info = JSON.parse(body);\n                log('parsed response, error?', info.error);\n                if (info.error) {\n                    log('error parsing\\n' + body + '\\n');\n                    var str = formNpmErrorMessage(name, info);\n                    console.error(str);\n\n                    if (isNotFound(info.error)) {\n                        deferred.resolve({\n                            name: name,\n                            versions: []\n                        });\n                        return;\n                    }\n\n                    deferred.reject(str);\n                    return;\n                }\n                log('extracting versions');\n                var versions = extractVersions(info);\n                log('versions', versions);\n\n                if (!Array.isArray(versions)) {\n                    throw new Error('Could not get versions for ' + name +\n                        ' from ' + JSON.stringify(info) +\n                        ' response ' + JSON.stringify(response, null, 2));\n                }\n\n                var validVersions = versions.filter(cleanVersionForName);\n                var newerVersions = validVersions.filter(isLaterVersion);\n                log('valid versions', validVersions);\n                log('newer versions', newerVersions);\n\n                deferred.resolve({\n                    name: name,\n                    versions: newerVersions\n                });\n                return;\n            } catch (err) {\n                console.error(err);\n                deferred.reject('Could not fetch versions for ' + name);\n                return;\n            }\n        }\n    });\n\n    return deferred.promise;\n}\n\n// returns a promise with available new versions\nfunction nextVersions(options, nameVersionPairs, checkLatestOnly) {\n    check.verify.object(options, 'expected object with options');\n    check.verify.array(nameVersionPairs, 'expected array');\n    checkLatestOnly = !!checkLatestOnly;\n    nameVersionPairs = cleanVersions(nameVersionPairs);\n\n    var MAX_CHECK_TIMEOUT = 10000;\n\n    if (!options.tldr) {\n        console.log('checking NPM registry');\n    }\n    var fetchPromises = nameVersionPairs.map(fetchVersions);\n    var fetchAllPromise = q.all(fetchPromises)\n        .timeout(MAX_CHECK_TIMEOUT, 'timed out waiting for NPM');\n\n    return fetchAllPromise.then(function (results) {\n        check.verify.array(results, 'expected list of results');\n        log('fetch all new version results');\n        log(results);\n\n        var available = results.filter(function (nameNewVersions) {\n            return nameNewVersions &&\n                check.array(nameNewVersions.versions) &&\n                nameNewVersions.versions.length;\n        });\n        if (checkLatestOnly) {\n            available = available.map(function (nameVersions) {\n                if (nameVersions.versions.length > 1) {\n                    nameVersions.versions = nameVersions.versions.slice(-1);\n                }\n                return nameVersions;\n            });\n        } else {\n            console.log('checking ALL versions');\n        }\n        return available;\n    }, function (error) {\n        return q.reject(error);\n    });\n}\n\nmodule.exports = {\n    isUrl: isUrl,\n    cleanVersion: cleanVersion,\n    cleanVersions: cleanVersions,\n    fetchVersions: fetchVersions,\n    nextVersions: nextVersions\n};\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/local-module-version.js":"var check = require('check-more-types');\nvar fs = require('fs');\nvar path = require('path');\n\n// sync returns version\nfunction getLocalModuleVersion(name) {\n    check.verify.string(name, 'missing name string');\n\n    try {\n        var filename = path.join('node_modules', name, 'package.json');\n        var contents = fs.readFileSync(filename, 'utf-8');\n        var pkg = JSON.parse(contents);\n        return pkg.version;\n    } catch (error) {\n        console.error('could not fetch version for local module', name);\n        console.error(error);\n        return null;\n    }\n}\n\nmodule.exports = getLocalModuleVersion;\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/test-module-version.js":"var la = require('lazy-ass');\r\nvar check = require('check-more-types');\r\nvar verify = check.verify;\r\nvar q = require('q');\r\nvar _ = require('lodash');\r\nvar semver = require('semver');\r\nvar quote = require('quote');\r\nvar installModule = require('./module-install');\r\nvar reportSuccess = require('./report').reportSuccess;\r\nvar reportFailure = require('./report').reportFailure;\r\nvar stats = require('./stats');\r\n\r\nvar cleanVersions = require('./registry').cleanVersions;\r\ncheck.verify.fn(cleanVersions, 'cleanVersions should be a function');\r\n\r\nvar revertModules = require('./revert');\r\ncheck.verify.fn(revertModules, 'revert is not a function, but ' +\r\n    JSON.stringify(revertModules));\r\n\r\nvar npmTest = require('./npm-test').test;\r\nvar execTest = require('./exec-test');\r\nvar report = require('./report-available');\r\nvar filterAllowed = require('./filter-allowed-updates');\r\n\r\n// expect array of objects, each {name, versions (Array) }\r\n// returns promise\r\nfunction testModulesVersions(options, available) {\r\n    verify.object(options, 'missing options');\r\n    verify.array(available, 'expected array of available modules');\r\n\r\n    var cleaned = cleanVersions(options.modules);\r\n    // console.log('cleaned', cleaned);\r\n    // var listed = _.zipObject(cleaned);\r\n    var names = _.pluck(cleaned, 'name');\r\n    var listed = _.zipObject(names, cleaned);\r\n\r\n    /*\r\n    console.log('testing module versions');\r\n    console.log('current versions', listed);\r\n    console.log('options', options);\r\n    console.log('available', available);\r\n    */\r\n\r\n    var allowed = filterAllowed(listed, available, options);\r\n    la(check.array(allowed), 'could not filter allowed updates', listed, available, options);\r\n\r\n    if (available.length && !allowed.length) {\r\n        console.log('No updates allowed using option', quote(options.allow || options.allowed));\r\n        console.log(available.length + ' available updates filtered');\r\n        return q(listed);\r\n    }\r\n\r\n    // console.log('allowed', allowed);\r\n    return q.when(report(allowed, listed, options))\r\n        .then(function testInstalls() {\r\n            // console.log('testing installs');\r\n            if (options.all) {\r\n                var install = installAll(allowed, options);\r\n                console.assert(install, 'could not get install all promise');\r\n                var test = testPromise(options, options.command);\r\n                console.assert(test, 'could not get test promise for command', options.command);\r\n                // console.dir(listed);\r\n                // console.dir(options.modules);\r\n\r\n                var installThenTest = install.then(test);\r\n                if (options.keep) {\r\n                    return installThenTest;\r\n                }\r\n\r\n                var revert = revertModules.bind(null, listed);\r\n                console.assert(revert, 'could not get revert promise');\r\n                return installThenTest.then(revert);\r\n            }\r\n\r\n            return installEachTestRevert(listed, allowed,\r\n                options.command, options.color, options.keep, options.tldr);\r\n        });\r\n}\r\n\r\n// returns promise, does not revert\r\nfunction installAll(available, options) {\r\n    verify.array(available, 'expected array');\r\n\r\n    var installFunctions = available.map(function (nameVersions) {\r\n        var name = nameVersions.name;\r\n        var version = nameVersions.versions[0];\r\n        verify.string(name, 'missing module name from ' +\r\n            JSON.stringify(nameVersions));\r\n        verify.string(version, 'missing module version from ' +\r\n            JSON.stringify(nameVersions));\r\n\r\n        var installOptions = {\r\n            name: name,\r\n            version: version,\r\n            keep: keep,\r\n            tldr: tldr\r\n        };\r\n        var installFunction = installModule.bind(null, installOptions);\r\n        return installFunction;\r\n    });\r\n    var installAllPromise = installFunctions.reduce(q.when, q());\r\n    return installAllPromise;\r\n}\r\n\r\nfunction installEachTestRevert(listed, available, command, color, keep, tldr) {\r\n    verify.object(listed, 'expected listed object');\r\n    verify.array(available, 'expected array');\r\n\r\n    var checkModulesFunctions = available.map(function (nameVersion) {\r\n        var name = nameVersion.name;\r\n        var currentVersion = listed[name].version;\r\n        la(check.string(currentVersion), 'cannot find current version for', name,\r\n            'among current dependencies', listed);\r\n\r\n        var installOptions = {\r\n            name: name,\r\n            version: currentVersion,\r\n            keep: keep,\r\n            tldr: tldr\r\n        };\r\n        var revertFunction = installModule.bind(null, installOptions);\r\n\r\n        var checkModuleFunction = testModuleVersions.bind(null, {\r\n            moduleVersions: nameVersion,\r\n            revertFunction: revertFunction,\r\n            command: command,\r\n            color: color,\r\n            currentVersion: currentVersion,\r\n            keep: keep,\r\n            tldr: tldr\r\n        });\r\n        return checkModuleFunction;\r\n    });\r\n    var checkAllPromise = checkModulesFunctions.reduce(q.when, q());\r\n    return checkAllPromise;\r\n}\r\n\r\n// test particular dependency with multiple versions\r\n// returns promise\r\nfunction testModuleVersions(options, results) {\r\n    verify.object(options, 'missing options');\r\n    var nameVersions = options.moduleVersions;\r\n    var restoreVersionFunc = options.revertFunction;\r\n\r\n    var name = nameVersions.name;\r\n    var versions = nameVersions.versions;\r\n    verify.string(name, 'expected name string');\r\n    verify.array(versions, 'expected versions array');\r\n    results = results || [];\r\n    verify.array(results, 'expected results array');\r\n    if (!semver.valid(options.currentVersion)) {\r\n        throw new Error('do not have current version for ' + name);\r\n    }\r\n\r\n    var deferred = q.defer();\r\n    var checkPromises = versions.map(function (version) {\r\n        return testModuleVersion.bind(null, {\r\n            name: name,\r\n            version: version,\r\n            command: options.command,\r\n            color: options.color,\r\n            currentVersion: options.currentVersion,\r\n            tldr: options.tldr\r\n        });\r\n    });\r\n    var checkAllPromise = checkPromises.reduce(q.when, q());\r\n    if (options.keep) {\r\n        checkAllPromise = checkAllPromise.then(function (result) {\r\n            verify.array(result, 'expected array of results', result);\r\n            var lastSuccess = _.last(_.filter(result, { works: true }));\r\n            if (lastSuccess) {\r\n                console.log('keeping last working version', lastSuccess.name + '@' + lastSuccess.version);\r\n                return installModule({\r\n                    name: lastSuccess.name,\r\n                    version: lastSuccess.version,\r\n                    keep: true,\r\n                    tldr: options.tldr\r\n                }, result);\r\n            } else {\r\n                return restoreVersionFunc().then(function () {\r\n                    // console.log('returning result after reverting', result);\r\n                    return q(result);\r\n                });\r\n            }\r\n        });\r\n    } else {\r\n        checkAllPromise = checkAllPromise\r\n            .then(restoreVersionFunc);\r\n    }\r\n    checkAllPromise\r\n        .then(function (result) {\r\n            check.verify.array(result, 'could not get result array');\r\n            results.push(result);\r\n            deferred.resolve(results);\r\n        }, function (error) {\r\n            console.error('could not check', nameVersions, error);\r\n            deferred.reject(error);\r\n        });\r\n\r\n    return deferred.promise;\r\n}\r\n\r\nvar logLine = (function formLine() {\r\n    var n = process.stdout.isTTY ? process.stdout.columns : 40;\r\n    verify.positiveNumber(n, 'expected to get terminal width, got ' + n);\r\n    var k;\r\n    var str = '';\r\n    for(k = 0; k < n; k += 1) {\r\n        str += '-'\r\n    }\r\n    return function () {\r\n        console.log(str);\r\n    };\r\n}());\r\n\r\n// checks specific module@version\r\n// returns promise\r\nfunction testModuleVersion(options, results) {\r\n    verify.object(options, 'missing test module options');\r\n    verify.string(options.name, 'missing module name');\r\n    verify.string(options.version, 'missing version string');\r\n    verify.unemptyString(options.currentVersion, 'missing current version');\r\n\r\n    if (options.command) {\r\n        verify.string(options.command, 'expected command string');\r\n    }\r\n    // console.log('options', options);\r\n\r\n    results = results || [];\r\n    verify.array(results, 'missing previous results array');\r\n\r\n    var nameVersion = options.name + '@' + options.version;\r\n\r\n    if (!options.tldr) {\r\n        console.log('\\ntesting', nameVersion);\r\n    }\r\n\r\n    var result = {\r\n        name: options.name,\r\n        version: options.version,\r\n        from: options.currentVersion,\r\n        works: true\r\n    };\r\n\r\n    var test = testPromise(options, options.command);\r\n    console.assert(test, 'could not get test promise for command', options.command);\r\n\r\n    var deferred = q.defer();\r\n\r\n    var getSuccess = stats.getSuccessStats({\r\n        name: options.name,\r\n        from: options.currentVersion,\r\n        to: options.version\r\n    });\r\n\r\n    getSuccess\r\n        .then(stats.printStats.bind(null, options), function () {\r\n            console.log('could not get update stats', options.name);\r\n            return;\r\n        })\r\n        .then(function () {\r\n            return installModule({\r\n                name: options.name,\r\n                version: options.version,\r\n                keep: false,\r\n                tldr: options.tldr\r\n            });\r\n        })\r\n        .then(test)\r\n        .then(function () {\r\n            reportSuccess(nameVersion + ' works', options.color);\r\n\r\n            stats.sendUpdateResult({\r\n                name: options.name,\r\n                from: options.currentVersion,\r\n                to: options.version,\r\n                success: true\r\n            });\r\n            results.push(result);\r\n            deferred.resolve(results);\r\n        }, function (error) {\r\n            reportFailure(nameVersion + ' tests failed :(', options.color);\r\n\r\n            stats.sendUpdateResult({\r\n                name: options.name,\r\n                from: options.currentVersion,\r\n                to: options.version,\r\n                success: false\r\n            });\r\n\r\n            verify.number(error.code, 'expected code in error ' +\r\n                JSON.stringify(error, null, 2));\r\n\r\n            var horizontalLine = options.tldr ? _.noop : logLine;\r\n\r\n            horizontalLine();\r\n            if (!options.tldr) {\r\n                console.error('test finished with exit code', error.code);\r\n                verify.string(error.errors, 'expected errors string in error ' +\r\n                    JSON.stringify(error, null, 2));\r\n                console.error(error.errors);\r\n            }\r\n\r\n            horizontalLine();\r\n\r\n            result.works = false;\r\n            results.push(result);\r\n            deferred.resolve(results);\r\n        });\r\n    return deferred.promise;\r\n}\r\n\r\nfunction testPromise(options, command) {\r\n    var testFunction = npmTest.bind(null, options);\r\n    if (command) {\r\n        verify.unemptyString(command, 'expected string command, not ' + command);\r\n        testFunction = execTest.bind(null, options, command);\r\n    }\r\n    return testFunction;\r\n}\r\n\r\nmodule.exports = {\r\n    testModulesVersions: testModulesVersions,\r\n    testModuleVersion: testModuleVersion,\r\n    testPromise: testPromise\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/module-install.js":"var check = require('check-more-types');\r\nvar spawn = require('child_process').spawn;\r\nvar q = require('q');\r\nvar NPM_PATH = require('npm-utils').path;\r\nvar formInstallCommand = require('./report-install-command');\r\n\r\n// returns a promise\r\nfunction installModule(options, results) {\r\n    check.verify.object(options, 'missing options');\r\n    check.verify.string(options.name, 'expected module name string');\r\n    check.verify.string(options.version, 'expected version string');\r\n\r\n    if (options.keep) {\r\n        console.assert(typeof options.keep === 'boolean', 'invalid keep');\r\n    }\r\n    if (results) {\r\n        check.verify.array(results, 'missing results');\r\n    }\r\n\r\n    var cmd = formInstallCommand([[{\r\n        name: options.name,\r\n        version: options.version,\r\n        works: true\r\n    }]]);\r\n    check.verify.unemptyString(cmd, 'could not form install command');\r\n    cmd = cmd.trim();\r\n\r\n    var moduleVersion = options.name + '@' + options.version, npm;\r\n    if (options.keep) {\r\n        console.log('  ', cmd);\r\n        var args = cmd.split(' ');\r\n        args.shift();\r\n        args.push('--save-exact');\r\n        npm = spawn(NPM_PATH, args);\r\n    } else {\r\n        if (!options.tldr) {\r\n            console.log('  installing', moduleVersion);\r\n        }\r\n        npm = spawn(NPM_PATH, ['install', moduleVersion]);\r\n    }\r\n\r\n    var testOutput = '';\r\n    var testErrors = '';\r\n\r\n    npm.stdout.setEncoding('utf-8');\r\n    npm.stderr.setEncoding('utf-8');\r\n\r\n    function hasError(str) {\r\n        return /error/i.test(str);\r\n    }\r\n\r\n    npm.stdout.on('data', function (data) {\r\n        if (hasError(data)) {\r\n            console.log('stdout:', data);\r\n        }\r\n        testOutput += data;\r\n    });\r\n\r\n    npm.stderr.on('data', function (data) {\r\n        if (hasError(data)) {\r\n            console.log('stderr:', data);\r\n        }\r\n        testErrors += data;\r\n    });\r\n\r\n    npm.on('error', function (err) {\r\n        console.error('error:', err);\r\n        testErrors += err.toString();\r\n    });\r\n\r\n    var deferred = q.defer();\r\n    npm.on('exit', function (code) {\r\n        if (code) {\r\n            console.error('npm returned', code);\r\n            console.error('errors:\\n' + testErrors);\r\n            deferred.reject({\r\n                code: code,\r\n                errors: testErrors\r\n            });\r\n        } else {\r\n            if (!options.tldr) {\r\n                console.log(moduleVersion, 'installed successfully');\r\n            }\r\n            deferred.resolve(results);\r\n        }\r\n    });\r\n    return deferred.promise;\r\n}\r\n\r\nmodule.exports = installModule;\r\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/report-install-command.js":"var check = require('check-more-types');\n\nfunction loadPackage() {\n    var filename = './package.json';\n    var fs = require('fs');\n    if (fs.existsSync(filename)) {\n        var txt = fs.readFileSync(filename, 'utf-8');\n        if (txt) {\n            return JSON.parse(txt);\n        }\n    }\n}\n\nfunction saveOption(type) {\n    var saveCommands = {\n        dependencies: '--save --save-exact',\n        devDependencies: '--save-dev --save-exact',\n        peerDependencies: '--save-peer --save-exact'\n    };\n    return saveCommands[type];\n}\n\nfunction splitByType(updates, pkg) {\n    check.verify.array(updates, 'expected array of updates');\n    check.verify.object(pkg, 'expected package object');\n\n    var result = {\n        dependencies: [],\n        devDependencies: [],\n        peerDependencies: []\n    };\n\n    updates.forEach(function (moduleList) {\n        if (!moduleList.length) {\n            return;\n        }\n        var moduleName = moduleList[0].name;\n        check.verify.string(moduleName, 'missing module name');\n        if (pkg.dependencies && pkg.dependencies[moduleName]) {\n            result.dependencies.push(moduleList);\n        } else if (pkg.devDependencies && pkg.devDependencies[moduleName]) {\n            result.devDependencies.push(moduleList);\n        } else if (pkg.peerDependencies && pkg.peerDependencies[moduleName]) {\n            result.peerDependencies.push(moduleList);\n        } else {\n            console.warn('Could not find dependency for', moduleName, 'assuming normal');\n            result.dependencies.push(moduleList);\n        }\n    });\n    return result;\n}\n\nfunction installCommand(updates) {\n    check.verify.array(updates, 'expected array of updates');\n    if (!updates.length) {\n        return;\n    }\n\n    var cmd = '';\n    var pkg = loadPackage();\n    if (!pkg) {\n        // assume all dependencies are normal\n        cmd = installCommandType(updates, 'dependencies');\n    } else {\n\n        var updatesByDependencyType = splitByType(updates, pkg);\n        console.assert(updatesByDependencyType, 'could not split updates by type');\n\n        // console.log(updatesByDependencyType)\n\n        var depCmd = installCommandType(updatesByDependencyType.dependencies, 'dependencies');\n        var devCmd = installCommandType(updatesByDependencyType.devDependencies, 'devDependencies');\n        var peerCmd = installCommandType(updatesByDependencyType.peerDependencies,\n            'peerDependencies');\n        if (depCmd) {\n            cmd += depCmd + '\\n';\n        }\n        if (devCmd) {\n            cmd += devCmd + '\\n';\n        }\n        if (peerCmd) {\n            cmd += peerCmd + '\\n';\n        }\n    }\n    if (cmd) {\n        return cmd;\n    }\n}\n\nfunction getLatestWorkingVersion(versions) {\n    check.verify.array(versions, 'expected array of versions');\n    var working;\n    versions.forEach(function (info) {\n        check.verify.string(info.name, 'missing package name ' + info);\n        if (info.works) {\n            working = info;\n        }\n    });\n\n    return working;\n}\n\nfunction setWorkingVersion(updates) {\n    updates.forEach(function (moduleVersions) {\n        moduleVersions.latestWorkingVersion = getLatestWorkingVersion(moduleVersions);\n    });\n}\n\nfunction installCommandType(updates, type) {\n    check.verify.array(updates, 'expected array of updates');\n    if (!updates.length) {\n        return;\n    }\n    check.verify.string(type, 'missing type');\n\n    var saveCommand = saveOption(type);\n    if (!saveCommand) {\n        throw new Error('invalid dependency type ' + type);\n    }\n\n    setWorkingVersion(updates);\n\n    var originalCmd, cmd;\n    originalCmd = cmd = 'npm install ' + saveCommand;\n    updates.forEach(function (moduleVersions) {\n        var latestWorkingVersion = moduleVersions.latestWorkingVersion;\n        if (latestWorkingVersion) {\n            cmd += ' ' + latestWorkingVersion.name + '@' + latestWorkingVersion.version;\n        }\n    });\n\n    if (originalCmd === cmd) {\n        return;\n    }\n\n    return cmd;\n}\n\nmodule.exports = installCommand;\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/report.js":"var colors = require('cli-color');\nvar check = require('check-more-types');\nvar formInstallCommand = require('./report-install-command');\nvar _ = require('lodash');\nvar changedLog = require('changed-log');\nvar Q = require('q');\n\nvar colorAvailable = process.stdout.isTTY;\n\nfunction report(updates, options) {\n    options = options || {};\n    var useColors = Boolean(options.useColors) && colorAvailable;\n    check.verify.array(updates, 'expected array of updates');\n    // sets latest working version for each module too\n    var cmd = formInstallCommand(updates);\n\n    console.log('\\n> next updates:');\n    updates.forEach(function (moduleVersions) {\n        reportModule(moduleVersions, useColors);\n    });\n\n    var reportChanges = updates.map(function (moduleVersions) {\n        return _.partial(printChangedLog, moduleVersions, useColors);\n    });\n\n    function printInstallCommand() {\n        if (_.isUndefined(cmd)) {\n            console.log('> nothing can be updated :(');\n        } else {\n            if (options.keptUpdates) {\n                console.log('> kept working updates');\n            } else {\n                cmd = cmd.trim();\n                var lines = cmd.split('\\n').length;\n                if (lines === 1) {\n                    console.log('> use the following command to install working versions');\n                } else {\n                    console.log('> use the following commands to install working versions');\n                }\n                console.log(cmd);\n            }\n        }\n    }\n\n    function printError(err) {\n        console.error('Error reporting changes');\n        console.error(err.message);\n    }\n    var start = options.changedLog ?\n        reportChanges.reduce(Q.when, Q()).catch(printError) :\n        Q();\n    return start.then(printInstallCommand);\n}\n\nfunction reportModule(moduleVersions, useColors) {\n    check.verify.array(moduleVersions, 'expected module / versions array');\n    if (!moduleVersions.length) {\n        return;\n    }\n    var name = moduleVersions[0].name;\n    check.verify.unemptyString(name, 'missing module name from ' + JSON.stringify(moduleVersions));\n    var fromVersion = moduleVersions[0].from;\n    check.verify.unemptyString(fromVersion, 'missing from version from ' + JSON.stringify(moduleVersions));\n\n    if (useColors) {\n        var colorVersions = moduleVersions.map(function (info) {\n            return (info.works ? colors.greenBright : colors.redBright)(info.version);\n        });\n        var str = colorVersions.join(', ');\n        console.log(name + ' ' + fromVersion + ' -> ' + str);\n    } else {\n        console.log(name + '@' + fromVersion);\n        moduleVersions.forEach(function (info) {\n            console.log('  ' + info.version + ' ' + (info.works ? 'PASS' : 'FAIL'));\n        });\n    }\n}\n\nfunction printChangedLog(moduleVersions, useColors) {\n    var info = moduleVersions[0];\n\n    if (!info.works) {\n        return;\n    }\n    return changedLog({\n        name: info.name,\n        from: info.from,\n        to: info.version\n    });\n}\n\nfunction reportSuccess(text, useColors) {\n    if (colorAvailable && useColors) {\n        console.log(colors.greenBright(text));\n    } else {\n        console.log('PASS', text);\n    }\n}\n\nfunction reportFailure(text, useColors) {\n    if (colorAvailable && useColors) {\n        console.log(colors.redBright(text));\n    } else {\n        console.log('FAIL', text);\n    }\n}\n\nmodule.exports = {\n    report: report,\n    reportSuccess: reportSuccess,\n    reportFailure: reportFailure\n};\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/stats.js":"var verify = require('check-more-types').verify;\nvar request = require('request');\nvar Q = require('q');\nvar colors = require('cli-color');\nvar colorAvailable = process.stdout.isTTY;\n\nvar nextUpdateStatsUrl = require('../package.json')['next-update-stats'] ||\n    'http://next-update.herokuapp.com';\n\nfunction sendUpdateResult(options) {\n    verify.unemptyString(options.name, 'missing name');\n    verify.unemptyString(options.from, 'missing from version');\n    verify.unemptyString(options.to, 'missing to version');\n    if (options.success) {\n        options.success = !!options.success;\n    }\n\n    verify.webUrl(nextUpdateStatsUrl, 'missing next update stats server url');\n    var sendOptions = {\n        uri: nextUpdateStatsUrl + '/update',\n        method: 'POST',\n        json: options\n    };\n    request(sendOptions, function ignoreResponse() {});\n}\n\nfunction getSuccessStats(options) {\n    verify.unemptyString(options.name, 'missing name');\n    verify.unemptyString(options.from, 'missing from version');\n    verify.unemptyString(options.to, 'missing to version');\n\n    verify.webUrl(nextUpdateStatsUrl, 'missing next update stats server url');\n    var opts = {\n        uri: nextUpdateStatsUrl + '/package/' + options.name + '/' + options.from +\n            '/' + options.to,\n        method: 'GET',\n        json: options\n    };\n    var defer = Q.defer();\n    request(opts, function (err, response, stats) {\n        if (err || response.statusCode !== 200) {\n            if (response) {\n                if (response.statusCode !== 404) {\n                    console.error('could not get success stats for', options.name);\n                    console.error(opts);\n                }\n                console.error('response status:', response.statusCode);\n            }\n            if (err) {\n                console.error(err);\n            }\n            defer.reject(err);\n            return;\n        }\n        defer.resolve(stats);\n    });\n    return defer.promise;\n}\n\nfunction colorProbability(probability, options) {\n    if (probability === null) {\n        return '';\n    }\n\n    options = options || {};\n    var useColors = !!options.color && colorAvailable;\n    if (probability < 0 || probability > 1) {\n        throw new Error('Expected probability between 0 and 1, not ' + probability);\n    }\n    var probabilityStr = (probability * 100).toFixed(0) + '%';\n    if (useColors) {\n        if (probability > 0.8) {\n            probabilityStr = colors.greenBright(probabilityStr);\n        } else if (probability > 0.5) {\n            probabilityStr = colors.yellowBright(probabilityStr);\n        } else {\n            probabilityStr = colors.redBright(probabilityStr);\n        }\n    }\n    return probabilityStr;\n}\n\nfunction printStats(options, stats) {\n    verify.object(stats, 'missing stats object');\n    verify.unemptyString(stats.name, 'missing name');\n    verify.unemptyString(stats.from, 'missing from version');\n    verify.unemptyString(stats.to, 'missing to version');\n    stats.success = +stats.success || 0;\n    stats.failure = +stats.failure || 0;\n    var total = stats.success + stats.failure;\n    var probability = (total > 0 ? stats.success / total: 0);\n    var probabilityStr = colorProbability(probability, options);\n    console.log('stats:', stats.name, stats.from, '->', stats.to,\n        'success probability', probabilityStr,\n        stats.success, 'success(es)', stats.failure, 'failure(s)');\n}\n\nmodule.exports = {\n    sendUpdateResult: sendUpdateResult,\n    getSuccessStats: getSuccessStats,\n    printStats: printStats,\n    colorProbability: colorProbability,\n    url: nextUpdateStatsUrl\n};\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/revert.js":"var getDependenciesToCheck = require('./dependencies');\nvar installModule = require('./module-install');\nvar q = require('q');\n\n// returns promise\nfunction revert(moduleName) {\n    if (moduleName) {\n        console.log('reverting module', JSON.stringify(moduleName));\n    }\n\n    var toCheck = getDependenciesToCheck({}, moduleName);\n    var installPromises = toCheck.map(function (nameVersion) {\n        var name = nameVersion[0];\n        var version = nameVersion[1];\n        return installModule.bind(null, {\n            name: name,\n            version: version,\n            tldr: false\n        });\n    });\n    return installPromises.reduce(q.when, q());\n}\n\nmodule.exports = revert;\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/dependencies.js":"'use strict';\n\nvar debug = require('debug')('next-update');\nvar la = require('lazy-ass');\nvar check = require('check-more-types');\nvar path = require('path');\nvar print = require('./print-modules-table');\nvar nameVersionParser = require('./moduleName');\nvar getKnownDependencies = require('./get-known-dependencies');\nrequire('console.table');\nvar _ = require('lodash');\n\nla(check.fn(console.table), 'missing console.table method');\nla(check.fn(console.json), 'missing console.json method');\n\nfunction printCurrentModules(infos) {\n    check.verify.array(infos, 'expected array of modules');\n\n    var modules = [];\n    infos.forEach(function (nameVersionArray) {\n        check.verify.array(nameVersionArray, 'expected name version in ' + modules);\n        modules.push({\n            name: nameVersionArray[0],\n            version: nameVersionArray[1]\n        });\n    });\n    print(modules);\n}\n\nfunction printTable(options, nameVersionPairs) {\n    if (options.tldr) {\n        return;\n    }\n\n    var allowedType = options.type || 'all';\n    var title = 'module\\'s current dependencies:';\n    var filtered = allowedType === 'all' ?\n        nameVersionPairs :\n        _.filter(nameVersionPairs, { type: allowedType });\n\n    console.table(title, _.map(filtered, function (nameVersion) {\n        return {\n            module: nameVersion.name,\n            version: nameVersion.version,\n            type: nameVersion.type\n        };\n    }));\n}\n\nfunction getSkippedModules(packageFilename) {\n    var pkg = require(packageFilename);\n    var config = pkg &&\n        pkg.config &&\n        pkg.config['next-update'];\n    if (config) {\n        return config.skip ||\n            config.skipped ||\n            config.lock ||\n            config.locked ||\n            config.ignore ||\n            config.ignored ||\n            [];\n    }\n    return [];\n}\n\nfunction remove(nameVersionPairs, skipModules) {\n    check.verify.array(skipModules, 'expected list of modules to skip');\n    return nameVersionPairs.filter(function (dep) {\n        check.verify.unemptyString(dep.name, 'missing name for dependency');\n        return !_.includes(skipModules, dep.name);\n    });\n}\n\nfunction normalizeModuleNames(moduleNames) {\n    if (!moduleNames) {\n        return;\n    }\n    console.log('returning dependencies for');\n    console.dir(moduleNames);\n    if (check.string(moduleNames)) {\n        moduleNames = [moduleNames];\n    }\n\n    if (check.object(moduleNames)) {\n        var names = Object.keys(moduleNames);\n        moduleNames = names;\n    }\n\n    check.verify.array(moduleNames, 'expected module names array ' +\n        JSON.stringify(moduleNames));\n    return moduleNames;\n}\n\nfunction getDependenciesToCheck(options, moduleNames) {\n    check.verify.object(options, 'missing options');\n    debug('initial module names', moduleNames);\n    moduleNames = normalizeModuleNames(moduleNames);\n    debug('normalized module names', moduleNames);\n\n    var workingDirectory = process.cwd();\n\n    var packageFilename = path.join(workingDirectory, 'package.json');\n    var nameVersionPairs = getKnownDependencies(packageFilename);\n\n    var skipModules = getSkippedModules(packageFilename);\n    check.verify.array(skipModules, 'expected list of skipped modules');\n    if (skipModules.length) {\n        if (!options.tldr) {\n            console.log('ignoring the following modules', skipModules.join(', '));\n        }\n        nameVersionPairs = remove(nameVersionPairs, skipModules);\n    }\n    printTable(options, nameVersionPairs);\n\n    var toCheck = nameVersionPairs;\n    if (moduleNames) {\n        debug('matching module names', moduleNames);\n        toCheck = nameVersionPairs.filter(function (nameVersion) {\n            var name = nameVersion.name;\n            return moduleNames.some(function (aModule) {\n                var moduleName = nameVersionParser(aModule).name;\n                return name === moduleName;\n            });\n        });\n        if (!options.tldr) {\n            if (toCheck.length) {\n                console.log('only checking modules');\n                console.log(toCheck.map(function (m) {\n                    return m.name + '@' + m.version;\n                }));\n            } else {\n                console.log('Hmm, no modules to check');\n                console.log('from initial list\\n' +\n                    JSON.stringify(nameVersionPairs, null, 2));\n            }\n        }\n    }\n    return toCheck;\n}\n\nmodule.exports = getDependenciesToCheck;\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/print-modules-table.js":"var verify = require('check-more-types').verify;\nvar Table = require('easy-table');\nvar colorProbability = require('./stats').colorProbability;\n\nfunction markProbability(val, width) {\n    if (width === null) {\n        return val;\n    }\n    return Table.padLeft(val, width);\n}\n\nfunction printModulesTable(modules, options) {\n    verify.array(modules, 'expect an array of modules');\n    var haveStats = modules.some(function (m) {\n        return typeof m.stats === 'object';\n    });\n\n    var t = new Table();\n    modules.forEach(function (info) {\n        verify.string(info.name, 'missing module name ' + info);\n        verify.string(info.version, 'missing module version ' + info);\n\n        t.cell('package', info.name);\n        t.cell('current', info.from);\n        t.cell('available', info.version);\n\n        if (haveStats && info.stats) {\n            var stats = info.stats;\n            verify.object(stats, 'expected stats object');\n\n            var total = +stats.success + stats.failure;\n            var probability = total ? stats.success / total : null;\n            var probabilityStr = colorProbability(probability, options);\n            t.cell('success %', probabilityStr, markProbability);\n            t.cell('successful updates', info.stats.success, Table.Number(0));\n            t.cell('failed updates', info.stats.failure, Table.Number(0));\n        }\n        t.newRow();\n    });\n    console.log(t.toString());\n}\n\nmodule.exports = printModulesTable;\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/get-known-dependencies.js":"var check = require('check-more-types');\nvar _ = require('lodash');\nvar registry = require('./registry');\nvar cleanVersions = registry.cleanVersions;\n\nfunction format(label, deps) {\n    check.verify.unemptyString(label, 'missing label');\n    check.verify.object(deps, 'expected deps');\n    return Object.keys(deps).map(function (name) {\n        return {\n            type: label,\n            name: name,\n            version: deps[name]\n        };\n    });\n}\n\nfunction getKnownDependencies(packageFilename) {\n    check.verify.string(packageFilename, 'missing package filename string');\n\n    var workingPackage = require(packageFilename);\n\n    var dependencies = workingPackage.dependencies || {};\n    var devDependencies = workingPackage.devDependencies || {};\n    var peerDependencies = workingPackage.peerDependencies || {};\n\n    var all = [].concat(\n        format('prod', dependencies),\n        format('dev', devDependencies),\n        format('peer', peerDependencies)\n    );\n\n    var cleaned = cleanVersions(all);\n    // console.log('nameVersionPairs', cleaned);\n    return cleaned;\n}\n\nmodule.exports = getKnownDependencies;\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/npm-test.js":"'use strict';\n\nvar debug = require('debug')('next-update');\nvar check = require('check-more-types');\nvar spawn = require('child_process').spawn;\nvar q = require('q');\nvar _ = require('lodash');\n\n// hack to find npm bin script reliably\nfunction findNpmPath() {\n    var os = require('os');\n    var type = os.type();\n    return (/windows/gi).test(type) ? 'npm.cmd' : 'npm';\n}\n\nvar NPM_PATH = findNpmPath();\ndebug('found npm path %s', NPM_PATH);\n\nfunction argsToString(arrayLike) {\n    return Array.prototype.slice.call(arrayLike, 0).join(' ');\n}\n\nfunction writeToStderr() {\n    process.stderr.write(argsToString(arguments));\n}\n\nfunction writeToStdout() {\n    process.stderr.write(argsToString(arguments));\n}\n\n// returns a promise\nfunction test(options) {\n    options = options || {};\n    var log = options.tldr ? _.noop : writeToStdout;\n    var errorLog = options.tldr ? _.noop : writeToStderr;\n    log('  npm test');\n\n    check.verify.string(NPM_PATH, 'missing npm path string');\n    var npm = spawn(NPM_PATH, ['test']);\n    var testOutput = '';\n    var testErrors = '';\n\n    npm.stdout.setEncoding('utf-8');\n    npm.stderr.setEncoding('utf-8');\n\n    npm.stdout.on('data', function (data) {\n        testOutput += data;\n        log(data);\n    });\n\n    npm.stderr.on('data', function (data) {\n        testErrors += data;\n        log(data);\n    });\n\n    npm.on('error', function (err) {\n        errorLog(err);\n        testErrors += err.toString();\n    });\n\n    var deferred = q.defer();\n    npm.on('exit', function (code) {\n        if (code) {\n            errorLog('npm test returned', code);\n            errorLog('test errors:\\n' + testErrors);\n\n            deferred.reject({\n                code: code,\n                errors: testErrors\n            });\n        }\n        deferred.resolve();\n    });\n    return deferred.promise;\n}\n\nmodule.exports = {\n    test: test,\n    npmPath: findNpmPath()\n};\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/exec-test.js":"var check = require('check-more-types');\nvar verify = check.verify;\nvar spawn = require('child_process').spawn;\nvar q = require('q');\nvar npmPath = require('./npm-test').npmPath;\n\n// returns a promise\nfunction test(options, testCommand) {\n    options = options || {};\n    var log = options.tldr ? _.noop : console.log.bind(console);\n\n    verify.unemptyString(testCommand, 'missing test command string');\n    log(' ', testCommand);\n\n    var testParts = testCommand.split(' ');\n    console.assert(testParts.length > 0, 'missing any test words in ' + testCommand);\n    var testExecutable = testParts.shift();\n    verify.unemptyString(testExecutable, 'missing test executable for command ' + testCommand);\n    if (testExecutable === 'npm') {\n        testExecutable = npmPath;\n    }\n    var testProcess = spawn(testExecutable, testParts);\n    var testOutput = '';\n    var testErrors = '';\n\n    testProcess.stdout.setEncoding('utf-8');\n    testProcess.stderr.setEncoding('utf-8');\n\n    testProcess.stdout.on('data', function (data) {\n        testOutput += data;\n    });\n\n    testProcess.stderr.on('data', function (data) {\n        testErrors += data;\n    });\n\n    var deferred = q.defer();\n    testProcess.on('error', function (err) {\n        console.error('test command: \"' + testCommand + '\"');\n        console.error(err);\n        testErrors += err.toString();\n        deferred.reject({\n            code: err.code,\n            errors: testErrors\n        });\n    });\n\n    testProcess.on('exit', function (code) {\n        if (code) {\n            console.error('testProcess test returned', code);\n            console.error('test errors:\\n' + testErrors);\n            console.error(testOutput);\n            deferred.reject({\n                code: code,\n                errors: testErrors\n            });\n        }\n        deferred.resolve();\n    });\n    return deferred.promise;\n}\n\nmodule.exports = test;\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/report-available.js":"'use strict';\n\nvar la = require('lazy-ass');\nvar check = require('check-more-types');\nvar log = require('debug')('next-update');\n\nrequire('console.json');\nvar print = require('./print-modules-table');\nvar stats = require('./stats');\nvar clc = require('cli-color');\nvar getSuccess = stats.getSuccessStats;\nvar q = require('q');\n\nfunction ignore() {}\n\nfunction reportAvailable(available, currentVersions, options) {\n    la(check.array(available), 'expect an array of info objects', available);\n\n    if (!available.length) {\n        console.log('nothing new is available');\n        return [];\n    }\n\n    log('report available');\n    log(available);\n    log('current versions');\n    log(JSON.stringify(currentVersions));\n\n    la(check.maybe.object(currentVersions),\n        'expected current versions as an object, but was', currentVersions);\n\n    function getCurrentVersion(name) {\n        la(check.unemptyString(name), 'missing name');\n        if (!currentVersions) {\n            return;\n        }\n        if (check.string(currentVersions[name])) {\n            return currentVersions[name];\n        }\n        if (check.object(currentVersions[name])) {\n            la(check.string(currentVersions[name].version),\n                'missing version for', name, 'in', currentVersions);\n            return currentVersions[name].version;\n        }\n    }\n\n    var chain = q();\n    var updateStats = {};\n\n    available.forEach(function (info) {\n        la(check.unemptyString(info.name), 'missing module name', info);\n        la(check.array(info.versions), 'missing module versions', info);\n\n        var currentVersion = getCurrentVersion(info.name);\n        log('version for', info.name, currentVersion);\n\n        if (currentVersion) {\n            la(check.unemptyString(currentVersion),\n                'missing version', currentVersion, 'for', info.name);\n            updateStats[info.name] = {\n                name: info.name,\n                from: currentVersion\n            };\n        }\n\n        if (info.versions.length === 1) {\n            if (currentVersion) {\n                chain = chain.then(function () {\n                    return getSuccess({\n                        name: info.name,\n                        from: currentVersion,\n                        to: info.versions[0]\n                    }).then(function (stats) {\n                        updateStats[info.name] = stats;\n                    }).catch(ignore);\n                });\n            }\n        }\n    });\n\n    return chain.then(function () {\n        var modules = [];\n\n        available.forEach(function (info) {\n            la(check.unemptyString(info.name), 'missing module name', info);\n            la(check.array(info.versions), 'missing module versions', info);\n\n            var sep = ', ', versions;\n\n            if (info.versions.length < 5) {\n                versions = info.versions.join(sep);\n            } else {\n                versions = info.versions.slice(0, 2)\n                    .concat('...')\n                    .concat(info.versions.slice(info.versions.length - 2))\n                    .join(sep);\n            }\n\n            var stats = updateStats[info.name];\n            if (!stats) {\n                return;\n            }\n            la(check.object(stats), 'could not get stats for', info.name,\n                'all', updateStats, 'available stats', info);\n            modules.push({\n                name: info.name,\n                version: versions,\n                from: stats.from,\n                stats: stats\n            });\n        });\n        console.log('\\navailable updates:');\n        if (modules.length) {\n            print(modules, options);\n            console.log('update stats from', clc.underline(stats.url));\n        } else {\n            console.log(available);\n            console.log('no stats is available yet for these updates');\n        }\n        return available;\n    });\n}\n\nmodule.exports = reportAvailable;\n","/home/travis/build/npmtest/node-npmtest-next-update/node_modules/next-update/src/filter-allowed-updates.js":"var la = require('lazy-ass');\nvar check = require('check-more-types');\nvar semver = require('semver');\nvar _ = require('lodash');\n\nla(check.fn(semver.diff), 'semver missing diff method', semver);\n\nfunction isDiffAllowed(allowed, diff) {\n  la(check.unemptyString(allowed), 'invalid allowed update', allowed);\n  la(check.unemptyString(diff), 'invalid diff update', diff);\n\n  switch (allowed) {\n    case 'major':\n      return true;\n    break;\n    case 'minor':\n      return diff === 'minor' || diff === 'patch';\n    break;\n    case 'patch':\n      return diff === 'patch';\n    break;\n    default:\n      throw new Error('Invalid allowed update ' + allowed);\n    break;\n  }\n}\n\nfunction isDependencyTypeAllowed(allowed, current) {\n  la(check.unemptyString(allowed), 'expected allowed string', allowed);\n  la(check.unemptyString(current), 'expected current string', current);\n\n  allowed = allowed.trim().toLowerCase();\n  current = current.trim().toLowerCase();\n\n  if (allowed === 'all') {\n    return true;\n  }\n  return allowed === current;\n}\n\nfunction filterAllowedUpdates(current, available, options) {\n  var allowed = options.allow || options.allowed || 'major';\n  var isAllowed = _.partial(isDiffAllowed, allowed);\n\n  var type = options.type || 'all';\n  var isAllowedType = _.partial(isDependencyTypeAllowed, type);\n\n  // console.log('filtering available updates', available);\n  // console.log('current versions', current);\n\n  function filterVersions(fromVersion, toVersion) {\n    var diff = semver.diff(fromVersion, toVersion);\n    // console.log(availableUpdate.name, 'difference from', fromVersion, 'to', toVersion, diff);\n    return isAllowed(diff);\n  }\n\n  function allowedDependencyType(availableUpdate) {\n    var dependency = current[availableUpdate.name];\n    la(check.object(dependency),\n      'cannot find dependency for update', availableUpdate, 'in', current);\n    la(check.unemptyString(dependency.type),\n      'missing type of update', dependency);\n    return isAllowedType(dependency.type);\n  }\n\n  function filterHasNewVersions(availableUpdate) {\n      la(check.unemptyString(availableUpdate.name), 'missing name in available', availableUpdate);\n\n      var fromVersion = current[availableUpdate.name].version;\n      la(check.unemptyString(fromVersion),\n        'cannot find current version for', availableUpdate.name, current);\n\n      var versions = availableUpdate.versions;\n      la(check.array(versions), 'missing versions in update', availableUpdate);\n\n      var filteredVersions = versions.filter(_.partial(filterVersions, fromVersion));\n      availableUpdate.versions = filteredVersions;\n      return availableUpdate.versions.length > 0;\n  }\n\n  var filtered = available\n    .filter(filterHasNewVersions)\n    .filter(allowedDependencyType);\n\n  // console.log('filtered', filtered);\n  return filtered;\n}\n\nmodule.exports = check.defend(filterAllowedUpdates,\n  check.object, 'expected object with all current dependencies',\n  check.array, 'available list should be an array',\n  check.object, 'options should be an object');\n"}